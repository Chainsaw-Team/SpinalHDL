package chainsaw.projects.xdma.daq

import spinal.core._
import spinal.lib._
import spinal.lib.bus.amba4.axilite._
import spinal.lib.bus.amba4.axis._
import spinal.lib.bus.misc.SizeMapping
import spinal.lib.bus.regif.AccessType._
import spinal.lib.bus.regif._

import scala.language.postfixOps

// TODO: pulse generation and frame builder
case class ChainsawDaqDataPath() extends Component {

  // clock and reset inputs
  val controlClk, controlRstn, dataClk, dataRstn = in Bool ()

  // AXI4-Lite interface controlling this module
  val controlInConfig = AxiLite4Config(addressWidth = 32, dataWidth = 32)
  val controlIn = slave(AxiLite4(controlInConfig))

  // data from jesd204
  val dataInConfig = Axi4StreamConfig(dataWidth = 16)
  val dataIn = slave(Axi4Stream(dataInConfig))

  // data to AXI-DMA
  val dataOutConfig = Axi4StreamConfig(dataWidth = 8, useLast = true)
  val dataOut = master(Axi4Stream(dataOutConfig))

  // other outputs
  val channel0Probe, channel1Probe = out SInt (16 bits) // output to ILA
  val pulse0, pulse1 = out Bool () // pulse output to SMA
  val hmc7044Resetn, ad9695PowerDown, jesd204Reset = out Bool () // reset output to submodules

  controlIn.setNameForEda()
  dataIn.setNameForEda()
  dataOut.setNameForEda()

  // pre-assignment
  dataIn.ready.set()

  // creating clock domains
  val controlClockDomain =
    ClockDomain(
      clock = controlClk,
      reset = controlRstn,
      config = ClockDomainConfig(resetKind = SYNC, resetActiveLevel = LOW)
    )

  val dataClockDomain = new ClockDomain(
    clock = dataClk,
    reset = dataRstn,
    config = ClockDomainConfig(resetKind = SYNC, resetActiveLevel = LOW),
    frequency = FixedFrequency(250 MHz)
  )

  val controlClockingArea = new ClockingArea(controlClockDomain) {

    val userBaseAddr = 0x00000 // must be 0 when you use newReg rather than newRegAt
    val userBusIf = AxiLite4BusInterface(controlIn, SizeMapping(userBaseAddr, 0x10000))

    val versionReg = userBusIf.newRegAt(userBaseAddr, "firmware version")
    val revision = versionReg.field(UInt(8 bits), RO)
    val minor = versionReg.field(UInt(8 bits), RO)
    val major = versionReg.field(UInt(8 bits), RO)
    revision := 0x00
    minor := 0x01
    major := 0x00

    // reset control
    val jesd204ResetReg = userBusIf.newReg("reset JESD204")
    val jesd204Reset = jesd204ResetReg.field(Bool(), RW, 1, "reset JESD204, asserted by default")
    val hmc7044ResetReg = userBusIf.newReg("reset HMC7044")
    val hmc7044Reset = hmc7044ResetReg.field(Bool(), RW, 1, "reset HMC7044, asserted by default")
    val ad9695ResetReg = userBusIf.newReg("reset AD9695")
    val ad9695Reset = ad9695ResetReg.field(Bool(), RW, 1, "reset ad9695, asserted by default")

    // test control
    val rwTestReg = userBusIf.newReg("reserved RW field for testing AXI4-Lite read/write")
    val rwTest = rwTestReg.field(Bits(32 bits), RW)

    // datapath control
    val datapathControlReg = userBusIf.newReg("control mux in datapath")
    val testMode =
      datapathControlReg.field(Bool(), RW, "incrementing number will be generated by datapath when test mode turned on")
    val channelSelection = datapathControlReg.field(UInt(1 bits), RW, "select channel 0/1 as data source")

    // pulse generation control
    val pulsePeriodReg = userBusIf.newReg("pulse period / 4ns")
    val pulseLengthReg = userBusIf.newReg("pulse length / 4ns")
    val pulseWidthReg = userBusIf.newReg("pulse width / 4ns")
    val pulseWidthDelayReg = userBusIf.newReg("pulse0 -> pulse1 duration / 4ns")
    val preTriggerLengthReg = userBusIf.newReg("pre-trigger duration / 4ns")
    val postTriggerLengthReg = userBusIf.newReg("post-trigger duration / 4ns")

    val pulsePeriod = pulsePeriodReg.field(UInt(32 bits), RW)
    val pulseLength = pulseLengthReg.field(UInt(32 bits), RW)
    val pulseWidth = pulseWidthReg.field(UInt(32 bits), RW)
    val pulseWidthDelay = pulseWidthDelayReg.field(UInt(32 bits), RW)
    val preTriggerLength = preTriggerLengthReg.field(UInt(32 bits), RW)
    val postTriggerLength = postTriggerLengthReg.field(UInt(32 bits), RW)

    userBusIf.accept(HtmlGenerator("UserRegisterSpace", "AP"))
    userBusIf.accept(CHeaderGenerator("UserRegisterSpace", "AP"))
    userBusIf.accept(PythonHeaderGenerator("UserRegisterSpace", "AP"))

  }

  // reset connection
  hmc7044Resetn := !controlClockingArea.hmc7044Reset
  ad9695PowerDown := controlClockingArea.ad9695Reset
  jesd204Reset := controlClockingArea.jesd204Reset

  def getControlData[T <: Data](ctrl: T) = { // control clock domain -> data clock domain
    ctrl.addTag(crossClockDomain)
    Delay(ctrl, 3)
  }

  val dataClockingArea = new ClockingArea(dataClockDomain) {

    import controlClockingArea._

    // remap rx data to get meaningful data
    def mapper(bitsIn: Bits, base: Int) = { // earlier data in higher bits (63:48 is segment0, 47:32 is segment1, etc.)
      (0 until 4)
        .map { i =>
          val baseHigher = base + i * 8
          val baseLower = base + (i + 4) * 8
          val all = bitsIn(baseHigher + 7 downto baseHigher) ## bitsIn(baseLower + 7 downto baseLower)
          val controlBits = all.takeLow(2)
          all.takeHigh(14) ## B("00")
        }
        .reduce(_ ## _)
    }

    val channel0Segments = mapper(dataIn.payload.data, 0)
    val channel1Segments = mapper(dataIn.payload.data, 64)

    // pulse generator
    val counterWidth = 20
    println(
      f"counter width = $counterWidth, max period = ${(1 << counterWidth) * 4} ns, min frequency = ${1.0 / ((1 << counterWidth) * 4).toDouble * 1e9} Hz"
    )

    val counterForPulsePeriod = Counter(1 << counterWidth) // max =
    counterForPulsePeriod.increment() // free run
    when(counterForPulsePeriod.value === getControlData(pulsePeriod))(counterForPulsePeriod.clear())

    def getDuration(start: UInt, end: UInt) = {
      val durationStart = counterForPulsePeriod.value === RegNext(start.resize(counterWidth))
      val durationEnd = counterForPulsePeriod.value === RegNext(end.resize(counterWidth))
      val duration = RegInit(False)
      when(RegNext(durationStart).rise())(duration.set())
      when(RegNext(durationEnd).rise())(duration.clear())
      (duration, RegNext(durationEnd))
    }

    val (pulse0Valid, _) = getDuration(U(0, 32 bits), getControlData(pulseWidth))
    val (pulse1Valid, _) =
      getDuration(getControlData(pulseWidthDelay), getControlData(pulseWidthDelay) + getControlData(pulseWidth))
    val (dataValid, dataLast) =
      getDuration(getControlData(postTriggerLength), getControlData(postTriggerLength) + getControlData(pulseLength))

    // dataOut builder
    // TODO: monitor data loss

    // free-running stream as data source data source is actually not subject to the backpressure of the ready signal
    val streamRaw = Stream(Fragment(Bits(64 bits)))
    streamRaw.valid := dataValid
    streamRaw.last := dataLast

    val counterForTest = Counter(1 << 14) // counter for test mode
    when(!dataValid)(counterForTest.clear())
    when(dataValid)(counterForTest.increment())

    val packetIdWidth = 10
    val counterForPacket = Counter(1 << packetIdWidth, inc = dataLast)

    when(getControlData(controlClockingArea.testMode)) { // test data -> AXI DMA
      (0 until 4).foreach(i =>
        streamRaw.fragment(i * 16, 16 bits) := RegNext((counterForTest.value @@ U(i, 2 bits)).asBits)
      )
    }.otherwise { // JESD204 -> AXI DMA
      streamRaw.fragment := Mux(getControlData(channelSelection.asBool), channel1Segments, channel0Segments)
    }

    val header = counterForPacket ## B(0, (64 - packetIdWidth) bits)
    val streamWithHeader = streamRaw.insertHeader(header)
    val streamBuffered = streamWithHeader.queue(1024) // buffer between free-running & standard stream interface


    // TODO: method driving AXI4-Stream with Stream[Bits] or Stream[Fragment[Bits]]
    dataOut.valid := streamBuffered.valid
    dataOut.payload.last := streamBuffered.last
    dataOut.payload.data := streamBuffered.fragment
    streamBuffered.ready := dataOut.ready

    // pulse output
    pulse0 := pulse0Valid
    pulse1 := pulse1Valid

    // TODO: header insertion
    // TODO: linear fix
    // TODO: may need buffer between free-running streamOutWithHeader and dataOut

    // debug
    channel0Probe assignFromBits channel0Segments.takeLow(16)
    channel1Probe assignFromBits channel1Segments.takeLow(16)
    val counterValue = out UInt (14 bits)
    counterValue := counterForTest.value
    val dataLoss = out Bool ()
    dataLoss := streamRaw.valid && !streamRaw.ready // when cyclic scatter gather DMA stars, this should always be deasserted

  }

}
